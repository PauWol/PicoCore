{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PicoCore \u2014 Documentation","text":"<p>PicoCore \u2014 a lightweight, power-efficient MicroPython framework for Raspberry Pi Pico and Pico W.</p> <p>Designed for small autonomous robots, weather stations, and edge devices \u2014 simple to use, modular, and efficient.</p> <p>This is a work in progress. Please don't use this documentation as-is yet.</p> <p>Some parts of the documentation and concepts are ai written mockups and need to be updated. Still there are many good ideas and concepts that need to be fleshed out. Be patient and check back soon!</p>"},{"location":"#about-history","title":"About &amp; History","text":"<p>Before diving into PicoCore V2, it's useful to understand the project's history and why V2 exists. The original PicoCore V1 is preserved as a legacy release due to major architectural flaws. Lessons learned from V1 inspired the design of V2, improving power efficiency, modularity, and maintainability.</p> <p>Read the full story \u2192</p>"},{"location":"#what-is-picocore-v2","title":"What is PicoCore V2?","text":"<p>PicoCore V2 is a MicroPython-first runtime and set of libraries that:</p> <ul> <li>Focuses on small size and low power operation for Pico/Pico W devices.</li> <li>Exposes a simple service API for sensors, telemetry, and autonomous behaviors.</li> <li>Provides tools and scripts for building <code>.mpy</code> modules (compiled MicroPython) and for deploying documentation with MkDocs.</li> <li>Reuses good ideas from the V1 prototype but is a fresh, robust redesign.</li> </ul>"},{"location":"#quickstart-5-minutes","title":"Quickstart (5 minutes)","text":"<p>A more comprehensive setup guide can be found here</p>"},{"location":"#1-download-picocore-release","title":"1. Download PicoCore release","text":"<ul> <li>Go to the releases page.</li> <li>Download the latest <code>.zip</code> or <code>.7z</code> archive.</li> <li> <p>Inside the archive you will usually find:</p> </li> <li> <p>a <code>README.md</code> or <code>instructions.txt</code></p> </li> <li>precompiled <code>.mpy</code> libraries (the PicoCore API/runtime)</li> <li>usually a matching MicroPython <code>.uf2</code> firmware file.</li> </ul>"},{"location":"#2-flash-micropython-firmware","title":"2. Flash MicroPython firmware","text":"<ul> <li>Hold the BOOTSEL button on your Pico/Pico W and connect it to your PC via USB.</li> <li>It will mount as a RPI-RP2 drive.</li> <li>If the release archive contains a <code>.uf2</code>, copy it directly to the device.</li> <li>If no <code>.uf2</code> is included, check the version hint in the README and download the correct MicroPython <code>.uf2</code> from micropython.org.</li> <li>After copying, the device will reboot and unmount.</li> </ul>"},{"location":"#3-copy-picocore-runtime","title":"3. Copy PicoCore runtime","text":"<ul> <li>Use Thonny or the provided helper script in the scripts folder to copy the PicoCore <code>.mpy</code> library folder to your Pico.</li> <li>Also copy any <code>config.toml</code>, <code>boot.py</code>, or <code>main.py</code> files included in the release.</li> </ul>"},{"location":"#4-verify-installation","title":"4. Verify installation","text":"<ul> <li>Open a REPL (e.g. Thonny) and import a PicoCore module to check it works.</li> <li>Once everything is on the device, you are ready to start programming with PicoCore.</li> </ul> <p>Continue: Using PicoCore \u2192</p>"},{"location":"#build-release-compiled-mpy","title":"Build &amp; Release (compiled <code>.mpy</code>)","text":"<ul> <li>Compiled modules for MicroPython are stored per-release in <code>/releases/</code> (e.g. <code>releases/v2.0.0/core.mpy</code>).</li> <li> <p>Release naming convention:</p> </li> <li> <p>Active: <code>v2.x.y</code> (semantic versioning)</p> </li> <li>Legacy: <code>v1.x.y-legacy</code> (explicit legacy/deprecated tags)</li> </ul> <p>Build steps (example):</p> <pre><code># Use provided helper script (Windows)\nscripts\\compile.bat\n\n# Example output\n# build/core/*.mpy\n# build/core/.version  &lt;-- version written after successful build\n</code></pre>"},{"location":"#versioning-legacy-notes","title":"Versioning &amp; Legacy Notes","text":"<p>Legacy \u2014 PicoCore V1</p> <p>PicoCore V1 is preserved for historical and reference purposes only. It contained architectural issues that led to the V2 rewrite. Do not use it in new projects. See the releases page for <code>v1.*-legacy</code> archives and migration notes.</p> <p>Continue: Read about Versioning (Contributor) \u2192</p>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph LR\n  boot[\"boot.py\"] --&gt;|calls| coreInit[\"core.init()\"]\n  coreInit --&gt;|initializes| svcMgr[\"Service Manager\"]\n  svcMgr --&gt;|manages| sensors[\"Sensor Drivers\"]\n  svcMgr --&gt;|logs to| telemetry[\"Telemetry / Logging\"]\n  svcMgr --&gt;|handles| net[\"Network (Pico W)\"]\n  svcMgr --&gt;|starts| apps[\"Application Services (Weather / Rover)\"]\n  apps --&gt; weather[\"Weather Service\"]\n  apps --&gt; rover[\"Rover Service\"]</code></pre> <ul> <li><code>boot.py</code> calls a small initialization method from <code>/core/</code>.</li> <li><code>/core/</code> implements the service manager, drivers, and core APIs.</li> <li>Applications register services and are started by the service manager.</li> </ul>"},{"location":"#recommended-repo-layout","title":"Recommended Repo Layout","text":"<pre><code>my-project/\n\u251c\u2500 src/                # core source (MicroPython)\n\u251c\u2500 build/              # auto-generated compiled outputs\n\u251c\u2500 core/               # runtime API (core modules)\n\u251c\u2500 docs/               # mkdocs sources (this site)\n\u251c\u2500 scripts/            # build &amp; deploy scripts (compile.bat)\n\u251c\u2500 releases/           # packaged release assets (.zip/.tar or direct .mpy)\n\u251c\u2500 venv/               # local virtualenv (gitignored)\n\u251c\u2500 README.md\n\u2514\u2500 requirements.txt\n</code></pre>"},{"location":"#contributing-development","title":"Contributing &amp; Development","text":"<ul> <li>See CONTRIBUTING for code style, tests, and PR process.</li> <li>Use the <code>scripts/compile.bat</code> to produce <code>.mpy</code> artifacts.</li> <li>Keep your <code>.version</code> updated in <code>/core</code> (or <code>src</code>) when making incompatible changes.</li> </ul>"},{"location":"#troubleshooting-common-items","title":"Troubleshooting (common items)","text":"<ul> <li><code>mkdocs</code> not found \u2014 activate venv and <code>pip install mkdocs mkdocs-material</code>.</li> <li>Build scripts fail \u2014 run from <code>cmd.exe</code> on Windows; script logs the resolved paths.</li> <li>Pico not detected \u2014 ensure device is mounted correctly and you have the correct firmware / MicroPython UF2.</li> </ul>"},{"location":"#contact-links","title":"Contact &amp; Links","text":"<ul> <li>GitHub: PauWol/PicoCore</li> <li>Issues &amp; feature requests: Use the repository Issues page.</li> <li>License: See <code>LICENSE</code> in the repo root.</li> </ul>"},{"location":"about/","title":"About PicoCore","text":"<p>Abstract</p> <p>The story behind PicoCore: evolution, lessons learned, and the drive to make something that actually works.</p>"},{"location":"about/#legacy-picocore-v1","title":"Legacy PicoCore V1","text":"<p>The original PicoCore V1 was an experimental MicroPython framework for Raspberry Pi Pico devices. It aimed to simplify building small autonomous projects like weather stations and basic robots.</p> <p>Key points about V1:</p> <ul> <li>Legacy Only: The V1 codebase is preserved only as a legacy release. It is no longer maintained due to major design flaws.</li> <li>Limited Use: While some concepts and code were useful, the architecture failed to deliver low power consumption in practice.</li> <li>Practical Testing: I once built a quick prototype weather station using scrap parts and a DHT11 sensor. Despite my calculations predicting at least 2 days of battery life, it barely lasted ~5 hours. Apparently, that tiny blinking indicator LED I mounted outside was a battery vampire.</li> <li>Lessons Learned: V1 highlighted poor service management, inefficient sensor polling, and general inefficiency. Coding felt awkward and more complicated than standard MicroPython, and my so-called PicoOS turned out to be more of a misnomer.</li> </ul> <p>You can find V1 in the releases as a reference, but do not use it for new projects.</p>"},{"location":"about/#my-story-motivation-for-picocore-v2","title":"My Story &amp; Motivation for PicoCore V2","text":"<p>After V1, I had a grand vision: build an actual OS for a small robot I was designing. Many side projects pulled me away, and I realized quickly that PicoOS wasn\u2019t really an OS. Embedding and recompiling the MicroPython firmware was a nightmare \u2014 hello CMake, Windows, WSL, and compiler headaches.</p> <p>So, I pivoted: I switched to <code>.mpy</code>-converted library-like files, making the \u201cOS\u201d more of a runtime API. The name stuck, even if it was misleading.</p> <p>One weekend \u2014 fueled by coffee and little sleep \u2014 I rewrote the whole PicoCore \u201cOS\u201d from scratch. By the end, tests on my lab setup (my dorm PC) were working perfectly. I grabbed a bunch of scrap materials and spent the rest of the weekend building a makeshift weather station:</p> <ul> <li>Hardware: Protein box enclosure, homemade PCB, improvised power supply from 4 Amazon batteries wired in series/parallel (~3.3\u20133.7 V, ~4 Ah).</li> <li>Design: DHT11 sensor in a modified pillbox with ventilation holes, cable routed into the body, indicator LED to blink every minute for 3 seconds.</li> <li>Goal: Measure temperature and humidity every 5 minutes overnight.</li> </ul> <p>The next morning? Disaster. Only 5 data points logged. The timestamps were all over the place. The LED had apparently murdered my battery. V1\u2019s approach wasn\u2019t cutting it.</p> <p>I realized it was time for a smarter, developer-friendly system:</p> <ul> <li>Precompiled PicoCore API/runtime with auto features: deep sleep, light sleep, CPU frequency adjustments, battery voltage monitoring, and more.</li> <li>Simple, intuitive code structure that actually works.</li> <li>A system that lets you focus on your project, not wrestling with the framework.</li> </ul> <p>V2 was born from trial, error, and caffeine-fueled determination. The goal? Make something usable, maintainable, and enjoyable \u2014 and, hopefully, well-documented so future evolutions are easier to manage.</p>"},{"location":"about/#picocore-v2","title":"PicoCore V2","text":"<p>PicoCore V2 addresses the shortcomings of V1:</p> <ul> <li>Redesigned Architecture: Modular service manager, improved sensor and power management, and a robust runtime API.</li> <li>Best Practices: Follows modern MicroPython and embedded system conventions.</li> <li>Low Power: Optimized to maximize battery life in real-world autonomous devices.</li> <li>Extensible: Easier to add sensors, robots, or IoT applications.</li> </ul> <p>V2 builds on the lessons learned from V1 but is robust, maintainable, and production-ready.</p>"},{"location":"contributing/","title":"Contributing to PicoCore","text":"<p>Thank you for considering contributing to PicoCore!\u00a0 </p> <p>We welcome contributions of all kinds \u2014 bug fixes, features, documentation, or even just sharing feedback.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#1-fork-clone","title":"1. Fork &amp; Clone","text":"<ul> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally:</li> </ul> <pre><code>git clone https://github.com/PauWol/PicoCore.git\ncd PicoCore\n</code></pre>"},{"location":"contributing/#2-create-a-branch","title":"2. Create a Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n</code></pre>"},{"location":"contributing/#3-make-your-changes","title":"3. Make Your Changes","text":"<ul> <li>Implement your feature or fix.</li> <li>Add/update tests where appropriate.</li> <li>Make sure your code is formatted and linted.</li> </ul>"},{"location":"contributing/#4-commit-push","title":"4. Commit &amp; Push","text":"<pre><code>git commit -m \"Add my new feature\"\ngit push origin feature/my-new-feature\n</code></pre>"},{"location":"contributing/#5-open-a-pull-request","title":"5. Open a Pull Request","text":"<ul> <li>Go to the original repository.</li> <li>Open a Pull Request (PR) from your branch.</li> <li>Fill in the PR template and describe your changes.</li> </ul>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":"<ul> <li>Use PEP8 for Python code.</li> <li>Keep the Rules for Developing Safety-Critical Code in mind.</li> <li>Keep functions and classes small and focused.</li> <li>Add docstrings and comments where needed.</li> </ul> <p>Versioning of PicoCore \u2192</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or have a feature request:</p> <ul> <li>Open an issue in GitHub Issues.</li> <li>Provide as much detail as possible (steps to reproduce, logs, screenshots, etc.).</li> </ul>"},{"location":"contributing/#documentation-contributions","title":"Documentation Contributions","text":"<p>Improving docs is just as valuable as writing code! You can:</p> <ul> <li>Fix typos or grammar.</li> <li>Expand examples.</li> <li>Add tutorials or guides.</li> </ul> <p>The documentation is built using MkDocs Material. To build locally:</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre>"},{"location":"contributing/#download-this-guide","title":"Download This Guide","text":"<p>You can download this contributing guide as a Markdown file here:</p> <p>Download Contributing Guide</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as this project (see LICENSE).</p>"},{"location":"hardware/","title":"Hardware","text":"<p>Overview of hardware components, version hints, and supported boards.</p> <p>Disclaimer: Pico series two will follow after stable build for series one</p> BoardsSensorsOthers Board Description <code>RPI Pico</code>  Standard MicroPython board for general use <code>RPI Pico W</code>  MicroPython board with WiFi support Sensor Description 1.26.1 Example Example sensor description Component Description 1.26.1 Example Example component description"},{"location":"setup/","title":"Getting Started with PicoCore","text":"<p>This guide helps you set up PicoCore from scratch, flash your board, and run your first program. It assumes you are using Raspberry Pi Pico or Pico W.</p>"},{"location":"setup/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"setup/#1-download-picocore-release","title":"1. Download PicoCore release","text":"<ul> <li>Go to the releases page.</li> <li>Download the latest <code>.zip</code> or <code>.7z</code> archive.</li> <li> <p>Inside the archive you will usually find:</p> </li> <li> <p><code>README.md</code> or <code>instructions.txt</code></p> </li> <li>precompiled <code>.mpy</code> libraries (the PicoCore API/runtime)</li> <li>a matching MicroPython <code>.uf2</code> firmware file (sometimes)</li> <li>some sort of hello world project in form of a <code>boot.py</code> and <code>main.py</code></li> </ul>"},{"location":"setup/#2-flash-micropython-firmware","title":"2. Flash MicroPython firmware","text":"Tip: BOOTSEL mode <p>To enter bootloader mode, hold BOOTSEL on your Pico/Pico W and plug it into your PC.</p> <ol> <li>Your board will mount as a RPI-RP2 drive.</li> <li> <p>Copy the <code>.uf2</code> firmware file onto it.</p> <ul> <li> <p>If no <code>.uf2</code> is included in the release, check the version in the <code>.version</code> file (highlited line) inside the <code>core</code> folder and download from micropython.org.</p> .version<pre><code>2.0.0\n1.26.1\n</code></pre> </li> </ul> </li> <li> <p>The board will reboot automatically and unmount.</p> </li> </ol>"},{"location":"setup/#3-copy-picocore-runtime","title":"3. Copy PicoCore runtime","text":"ThonnympremoteHelper Script <ol> <li> <p>Open Thonny</p> <p>If not installed go get it on thonny.org</p> <p>  It should look something like this </p> </li> <li> <p>Select Interpreter</p> <ul> <li> <p>In the bottom right corner of the Thonny window, you will see the interpreter used to run the code you write in Thonny.</p> </li> <li> <p>By default, Thonny uses the interpreter on the \u2018Local\u2019 computer (the one running Thonny).</p> </li> </ul> <p>  Click the Python interpreter and select MicroPython. </p> Check if it worked <ul> <li>Make sure that your Raspberry Pi Pico is connected to your computer and you have selected the MicroPython (Raspberry Pi Pico) interpreter.</li> <li>Look at the Shell panel at the bottom of the Thonny editor.</li> </ul> <p>  You should see something like this. </p> </li> <li> <p>Enable File View</p> <p> Click View in the top left corner and then Files in the dropdown list </p> </li> <li> <p>Copy a folder to the device</p> <p> Right-click core and select Upload to / </p> </li> </ol> <ol> <li> <p>Install mpremote <pre><code>pip install mpremote\n</code></pre></p> </li> <li> <p>Check available ports <pre><code>python -m mpremote connect list\n</code></pre></p> </li> <li> <p>Copy a folder to the device</p> <p><code>&lt;your-port&gt;</code> could be <code>COM13</code> and <code>&lt;your-folder&gt;</code> is usually <code>./core</code>.The <code>:</code> represents the root destination folder.</p> <pre><code>python -m mpremote connect &lt;your-port&gt; cp -r &lt;your-folder&gt; : #(1)!\n</code></pre> <ol> <li>More usage Info can be found on pypi.org</li> </ol> </li> </ol> <p>Disclaimer: No helper script there yet.</p>"},{"location":"setup/#4-verify-installation","title":"4. Verify installation","text":"<p>Open a REPL and test:</p> <pre><code>import core\nprint(core.version())\n</code></pre> <p>\u2705 If you see a version string, PicoCore is working.</p> <p>Continue: First Program \u2192</p>"},{"location":"setup/#first-program","title":"First Program","text":"<p>Let\u2019s blink the onboard LED using PicoCore APIs.</p> <pre><code>from core.gpio import LED\nimport time\n\nled = LED()\n\nfor i in range(5):\n    led.on()\n    time.sleep(0.5)\n    led.off()\n    time.sleep(0.5)\n</code></pre> <p>If the LED blinks five times, your setup is correct.</p> <p>Congratulations!</p> <p>You have successfully installed and tested PicoCore.</p>"},{"location":"setup/#configuration","title":"Configuration","text":"<p>PicoCore can be customized via <code>config.toml</code>.</p> <pre><code>[system]\n\n[system.logger]\nlevel = \"INFO\"\nbuffersize = 5\n...\n</code></pre> <p>See the Configuration Guide for details.</p> <p>Version differences</p> <p>Different PicoCore releases may ship with slightly different <code>config.toml</code> defaults. Always check the <code>README</code> in your release archive.</p>"},{"location":"setup/#external-resources","title":"External Resources","text":"<ul> <li>MicroPython Documentation</li> <li>Thonny IDE</li> <li>mpremote tool</li> <li>Raspberry Pi Pico Datasheet</li> <li>Getting Started Guide</li> </ul>"},{"location":"setup/#whats-next","title":"What\u2019s Next?","text":"<ul> <li>Learn about Services and Tasks</li> <li>Configure PicoCore with conf.toml</li> </ul>"},{"location":"api/V2/pins/adc/","title":"Getting Started with the ADC Class","text":"<p>This guide explains how to use the <code>ADC</code> class to read analog signals from a Raspberry Pi Pico or Pico W and convert them to voltage or real-world values.</p>"},{"location":"api/V2/pins/adc/#initialization","title":"Initialization","text":""},{"location":"api/V2/pins/adc/#1-create-an-adc-instance","title":"1. Create an ADC instance","text":"<pre><code>from core.io import ADC\n\n# Example: pin 26, no extra vref, scaling or offset\nadc = ADC(pin=26)\n</code></pre>"},{"location":"api/V2/pins/adc/#parameters","title":"Parameters","text":"RequiredOptionalAdvanced/Useful <ul> <li>pin: GPIO pin number connected to the analog signal.</li> </ul> <ul> <li>vref: Reference voltage for conversion (default 3.3V).</li> </ul> <ul> <li>scale: Multiplier for real-world conversion (default 1.0).</li> <li>offset: Offset added after scaling (default 0.0).</li> </ul> <p>Calibration</p> <p>The scale and offset values can be used to calibrate the ADC to match your specific application. Better to use the calibration function <code>adc.calibrate(real voltge)</code> instead.This requires a known real-world value to be provided.</p>"},{"location":"api/V2/pins/adc/#reading-values","title":"Reading Values","text":""},{"location":"api/V2/pins/adc/#2-raw-adc-reading","title":"2. Raw ADC Reading","text":"<pre><code>raw_value = adc.raw()\nprint(f\"Raw ADC: {raw_value}\")\n</code></pre> <ul> <li>Returns a value between 0 and 65535.</li> </ul>"},{"location":"api/V2/pins/adc/#3-voltage-measurement","title":"3. Voltage Measurement","text":"<pre><code>v = adc.voltage()\nprint(f\"Voltage: {v:.2f} V\")\n</code></pre> <ul> <li>Converts the raw reading into volts.</li> </ul> Equation: Calculating Voltage <p>The equation for voltage conversion is: $$ Voltage = \\frac{\\text{raw}}{65535} \\cdot V_{\\text{ref}} $$</p> <p>the raw value is the raw reading from the ADC as an integer between 0 and 65535 (read_u16), and Vref is the reference voltage in volts.</p>"},{"location":"api/V2/pins/adc/#4-real-world-value","title":"4. Real-World Value","text":"<pre><code>real_value = adc.real()\nprint(f\"Scaled value: {real_value}\")\n</code></pre> <ul> <li>Applies scaling and offset to get real-world units (like temperature or light intensity).</li> </ul>"},{"location":"api/V2/pins/adc/#sampling","title":"Sampling","text":""},{"location":"api/V2/pins/adc/#5-collect-multiple-samples","title":"5. Collect Multiple Samples","text":"<pre><code>samples = adc.samples(n=10, type='voltage', delay=0.01)\nprint(samples)\n</code></pre> <ul> <li><code>n</code>: number of samples</li> <li><code>type</code>: <code>raw</code>, <code>voltage</code>, or <code>real</code></li> <li><code>delay</code>: seconds between samples</li> </ul>"},{"location":"api/V2/pins/adc/#6-asynchronous-sampling","title":"6. Asynchronous Sampling","text":"<pre><code>samples = await adc.async_samples(n=10, type='real')\nprint(samples)\n</code></pre>"},{"location":"api/V2/pins/adc/#7-mean-value","title":"7. Mean Value","text":"<pre><code>avg = adc.mean(n=10, type='voltage')\nprint(f\"Average voltage: {avg:.2f} V\")\n</code></pre> <ul> <li>Use <code>async_mean</code> for asynchronous calculation.</li> </ul>"},{"location":"api/V2/pins/adc/#pin-connection-check","title":"Pin Connection Check","text":""},{"location":"api/V2/pins/adc/#8-check-if-pin-is-connected","title":"8. Check if Pin is Connected","text":"<pre><code>connected, info = adc.is_pin_connected(n=20, delay=0.001)\nprint(connected, info)\n</code></pre> <ul> <li>Returns a boolean and a dictionary with details.</li> <li>Detects floating, short-to-GND, or short-to-VCC conditions.</li> </ul>"},{"location":"api/V2/pins/adc/#9-asynchronous-check","title":"9. Asynchronous Check","text":"<pre><code>connected, info = await adc.async_is_pin_connected(n=20)\nprint(connected, info)\n</code></pre>"},{"location":"api/V2/pins/adc/#notes-tips","title":"Notes &amp; Tips","text":"<ul> <li>Use <code>voltage()</code> for direct voltage readings.</li> <li>Use <code>real()</code> for calibrated real-world measurements.</li> <li>Sampling with delay improves stability.</li> <li>Connection heuristics help avoid unreliable readings.</li> </ul>"},{"location":"api/V2/pins/adc/#external-resources","title":"External Resources","text":"<ul> <li>MicroPython ADC Documentation</li> <li>Raspberry Pi Pico Datasheet</li> </ul>"},{"location":"api/V2/pins/adc/#whats-next","title":"What\u2019s Next?","text":"<ul> <li>Learn about Asynchronous Tasks and uasyncio</li> <li>Explore Sensor Integration with PicoCore</li> </ul>"},{"location":"assets/CONTRIBUTING/","title":"Contributing to PicoCore","text":"<p>Thank you for considering contributing to PicoCore! \ud83c\udf89 We welcome contributions of all kinds \u2014 bug fixes, features, documentation, or even just sharing feedback.</p>"},{"location":"assets/CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":""},{"location":"assets/CONTRIBUTING/#1-fork-clone","title":"1. Fork &amp; Clone","text":"<ul> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally:</li> </ul> <pre><code>git clone https://github.com/&lt;your-username&gt;/PicoCore.git\ncd PicoCore\n</code></pre>"},{"location":"assets/CONTRIBUTING/#2-create-a-branch","title":"2. Create a Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n</code></pre>"},{"location":"assets/CONTRIBUTING/#3-make-your-changes","title":"3. Make Your Changes","text":"<ul> <li>Implement your feature or fix.</li> <li>Add/update tests where appropriate.</li> <li>Make sure your code is formatted and linted.</li> </ul>"},{"location":"assets/CONTRIBUTING/#4-commit-push","title":"4. Commit &amp; Push","text":"<pre><code>git commit -m \"Add my new feature\"\ngit push origin feature/my-new-feature\n</code></pre>"},{"location":"assets/CONTRIBUTING/#5-open-a-pull-request","title":"5. Open a Pull Request","text":"<ul> <li>Go to the original repository.</li> <li>Open a Pull Request (PR) from your branch.</li> <li>Fill in the PR template and describe your changes.</li> </ul>"},{"location":"assets/CONTRIBUTING/#code-style-guidelines","title":"Code Style Guidelines","text":"<ul> <li>Use PEP8 for Python code.</li> <li>Keep functions and classes small and focused.</li> <li>Add docstrings and comments where needed.</li> </ul>"},{"location":"assets/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or have a feature request:</p> <ul> <li>Open an issue in GitHub Issues.</li> <li>Provide as much detail as possible (steps to reproduce, logs, screenshots, etc.).</li> </ul>"},{"location":"assets/CONTRIBUTING/#documentation-contributions","title":"Documentation Contributions","text":"<p>Improving docs is just as valuable as writing code! You can:</p> <ul> <li>Fix typos or grammar.</li> <li>Expand examples.</li> <li>Add tutorials or guides.</li> </ul> <p>The documentation is built using MkDocs Material. To build locally:</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre>"},{"location":"assets/CONTRIBUTING/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as this project (see LICENSE).</p>"},{"location":"concepts/P10/","title":"NASA P10 Rules Adapted to MicroPython for PicoCore","text":"<p>This page adapts the NASA P10 coding rules to MicroPython development for PicoCore V2, explaining how to write reliable, efficient, and maintainable embedded Python code.</p>"},{"location":"concepts/P10/#overview","title":"Overview","text":"<p>NASA's P10 rules are designed for safety-critical systems to prevent unexpected runtime behavior and ensure deterministic execution. We adapt these rules for MicroPython and PicoCore projects, keeping in mind resource constraints.</p>"},{"location":"concepts/P10/#rule-mapping-to-micropython","title":"Rule Mapping to MicroPython","text":""},{"location":"concepts/P10/#1-avoid-complex-flow-constructs-goto-recursion","title":"1. Avoid complex flow constructs (goto, recursion)","text":"<p>Python does not have <code>goto</code>. Recursion is allowed but should be avoided in embedded projects due to limited stack.</p> <pre><code># \u274c Avoid deep recursion\n# def factorial(n):\n#     return n * factorial(n-1)\n\n# \u2705 Use iteration instead\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n</code></pre> <p>\ud83d\udca1 Tip: Use loops and simple function calls. Avoid call stacks that grow unpredictably.</p>"},{"location":"concepts/P10/#2-loops-must-have-fixed-bounds","title":"2. Loops must have fixed bounds","text":"<pre><code># \u2705 Fixed bound loop\nfor i in range(10):\n    print(i)\n\n# \u274c While with uncertain exit\nwhile sensor.read() != target:\n    time.sleep(0.1)\n</code></pre> <p>\ud83d\udca1 Tip: Use timeouts or fixed iterations instead of potentially infinite loops.</p>"},{"location":"concepts/P10/#3-avoid-heap-memory-allocation-after-initialization","title":"3. Avoid heap memory allocation after initialization","text":"<p>In MicroPython, creating new objects dynamically may allocate on the heap. Prefer preallocated buffers.</p> <pre><code># \u2705 Preallocate list\ndata = [0]*100\n\n# \u274c Appending dynamically in a loop\nfor i in range(100):\n    data.append(i)\n</code></pre> <p>\ud83d\udca1 Tip: Use fixed-size data structures. This improves determinism and reduces fragmentation.</p>"},{"location":"concepts/P10/#4-restrict-functions-to-a-single-printed-page","title":"4. Restrict functions to a single printed page","text":"<p>Keep functions small and focused.</p> <pre><code># \u2705 Small, clear functions\ndef read_temperature():\n    return sensor.read_temp()\n\ndef control_fan():\n    temp = read_temperature()\n    if temp &gt; 30:\n        fan.on()\n    else:\n        fan.off()\n</code></pre> <p>\ud83d\udca1 Tip: This improves readability and maintainability.</p>"},{"location":"concepts/P10/#5-use-runtime-assertions","title":"5. Use runtime assertions","text":"<p>Assertions help during development but halt execution in MicroPython, which may not be desirable for embedded runtime.</p> <pre><code># \u2705 Development-only assertions\nif __debug__:\n    assert 0 &lt;= temp &lt;= 50, \"Temperature out of range\"\n\n# \u2705 Runtime checks with handler\nif temp &lt; 0 or temp &gt; 50:\n    handle_error(temp)\n</code></pre> <p>\ud83d\udca1 Tip: Prefer <code>if</code> statements with error handling for production code to maintain deterministic behavior.</p>"},{"location":"concepts/P10/#6-restrict-the-scope-of-data","title":"6. Restrict the scope of data","text":"<pre><code># \u2705 Local variables\ndef compute():\n    temp = sensor.read()\n    return temp\n\n# \u274c Global variable abuse\ntemp = 0\n</code></pre> <p>\ud83d\udca1 Tip: Reduce side effects and keep memory usage predictable.</p>"},{"location":"concepts/P10/#7-check-return-values","title":"7. Check return values","text":"<pre><code># \u2705 Check return values\nstatus = motor.start()\nif not status:\n    handle_error(\"Motor failed\")\n\n# \u274c Ignore return\nmotor.start()\n</code></pre> <p>\ud83d\udca1 Tip: Explicitly handle all return values to ensure reliability.</p>"},{"location":"concepts/P10/#8-use-preprocessor-only-for-headersmacros","title":"8. Use preprocessor only for headers/macros","text":"<p>Not applicable in MicroPython. Instead, keep configuration in constants or <code>.toml</code> files.</p> <pre><code># \u2705 Constants\nMAX_TEMP = const(50)\n</code></pre>"},{"location":"concepts/P10/#9-limit-pointer-usage","title":"9. Limit pointer usage","text":"<p>Python abstracts pointers. Avoid complex references or closures that create memory indirections.</p> <pre><code># \u2705 Simple references\nsensor_ref = sensor\n</code></pre> <p>\ud83d\udca1 Tip: Avoid function pointers or dynamic callables for deterministic embedded behavior.</p>"},{"location":"concepts/P10/#10-compile-with-warnings","title":"10. Compile with warnings","text":"<p>In MicroPython, use linters like pylint or mypy to detect issues.</p> <pre><code>pylint pico_core\nmypy --strict pico_core\n</code></pre> <p>\ud83d\udca1 Tip: Treat linter warnings as errors in critical embedded code.</p>"},{"location":"concepts/P10/#additional-guidelines-for-micropython-embedded-projects","title":"Additional Guidelines for MicroPython Embedded Projects","text":"<ul> <li>Assertions: Use for development only, avoid blocking production runtime.</li> <li>Try/Except: Avoid heavy exception handling in loops; it is costly. Use pre-checks and validation before execution.</li> <li>Deterministic Execution: Precompute values, preallocate memory, avoid dynamic object creation in loops.</li> <li>Logging: Minimize logging in real-time loops; buffer or batch writes.</li> </ul>"},{"location":"concepts/P10/#example-sensor-polling-loop-deterministic-safe","title":"Example: Sensor Polling Loop (Deterministic &amp; Safe)","text":"<pre><code># Fixed iterations, preallocated buffer, safe checks\nreadings = [0]*60  # store 60 samples\nfor i in range(60):\n    temp = sensor.read()\n    if 0 &lt;= temp &lt;= 50:\n        readings[i] = temp\n    else:\n        readings[i] = None  # handle invalid data\n    time.sleep(5)  # 5s interval, fixed\n</code></pre> <p>\u2705 Combines multiple P10 principles: fixed loops, preallocated memory, and runtime checks.</p>"},{"location":"concepts/P10/#references","title":"References","text":"<ul> <li>Nasa Fprime : Fprime Coding Standard</li> <li>NASA P10 Coding Standard: NASA Technical Standard</li> <li>MicroPython Documentation: https://docs.micropython.org/</li> </ul>"},{"location":"concepts/naming/","title":"PicoCore API Naming Conventions &amp; Design Standards","text":""},{"location":"concepts/naming/#philosophy","title":"\ud83e\udded Philosophy","text":"<p>PicoCore follows a minimal, expressive, and deterministic API design philosophy. Every class, method, and constant should communicate intent and behavior clearly while remaining compact and consistent.</p>"},{"location":"concepts/naming/#goals","title":"Goals","text":"<ul> <li>Keep method names one-worded when possible.</li> <li>Prefer verbs for actions (e.g., <code>start()</code>, <code>stop()</code>, <code>read()</code>), nouns for properties (e.g., <code>state</code>, <code>voltage</code>).</li> <li>Favor clarity over abstraction, simplicity over hierarchy.</li> <li>APIs should be discoverable, consistent, and orthogonal.</li> </ul>"},{"location":"concepts/naming/#file-module-structure","title":"\ud83e\udde9 File &amp; Module Structure","text":"<p>Each hardware or service interface resides in its own module, named after its core functionality.</p> <p>Examples:</p> <pre><code>/core/drivers/adc.py\n/core/drivers/i2c.py\n/core/services/logger.py\n/core/services/scheduler.py\n</code></pre>"},{"location":"concepts/naming/#naming-pattern","title":"Naming Pattern","text":"Type Pattern Example File lowercase <code>adc.py</code> Class PascalCase <code>ADC</code>, <code>LoggerService</code> Function snake_case <code>read_raw()</code>, <code>set_mode()</code> Method (Public API) short lowercase <code>start()</code>, <code>stop()</code>, <code>read()</code>, <code>real()</code> Constant UPPERCASE <code>DEFAULT_VREF = 3.3</code>"},{"location":"concepts/naming/#core-api-design-rules","title":"\u2699\ufe0f Core API Design Rules","text":""},{"location":"concepts/naming/#1-class-design","title":"1. Class Design","text":"<p>Each driver or service should be self-contained and single-purpose, exposing a minimal API surface.</p> <pre><code>class ADC:\n    def __init__(self, pin, vref=3.3, r1=0.0, r2=1.0):\n        self.pin = pin\n        self.vref = vref\n        self.r1 = r1\n        self.r2 = r2\n\n    def raw(self):\n        \"\"\"Return raw ADC reading (0\u201365535).\"\"\"\n        ...\n\n    def voltage(self):\n        \"\"\"Return measured voltage at ADC pin.\"\"\"\n        ...\n\n    def real(self):\n        \"\"\"Return corrected external voltage (e.g., before divider).\"\"\"\n        ...\n\n    def mean(self, samples=10):\n        \"\"\"Return averaged voltage over N samples.\"\"\"\n        ...\n</code></pre>"},{"location":"concepts/naming/#2-method-naming","title":"2. Method Naming","text":"Type Description Example Action Performs operation <code>start()</code>, <code>stop()</code>, <code>reset()</code> Reader Returns state/value <code>read()</code>, <code>raw()</code>, <code>voltage()</code>, <code>real()</code> Writer Modifies internal state <code>set_mode()</code>, <code>configure()</code> Computation Returns calculated result <code>mean()</code>, <code>delta()</code>"},{"location":"concepts/naming/#naming-style-examples","title":"\ud83c\udf3f Naming Style Examples","text":""},{"location":"concepts/naming/#hardware-drivers","title":"Hardware Drivers","text":"Purpose Class Methods ADC <code>ADC</code> <code>raw()</code>, <code>voltage()</code>, <code>real()</code>, <code>mean()</code> GPIO <code>Pin</code> <code>high()</code>, <code>low()</code>, <code>toggle()</code>, <code>state()</code> PWM <code>PWM</code> <code>start()</code>, <code>duty()</code>, <code>freq()</code> I2C <code>I2C</code> <code>scan()</code>, <code>read()</code>, <code>write()</code>"},{"location":"concepts/naming/#services","title":"Services","text":"Purpose Class Methods Logger <code>Logger</code> <code>info()</code>, <code>warn()</code>, <code>error()</code>, <code>fatal()</code> Task Scheduler <code>Scheduler</code> <code>add()</code>, <code>remove()</code>, <code>run()</code> Error Manager <code>ErrorRegistry</code> <code>register()</code>, <code>resolve()</code>, <code>emit()</code>"},{"location":"concepts/naming/#functional-design","title":"\ud83d\udd27 Functional Design","text":""},{"location":"concepts/naming/#keep-method-names-predictable-and-parallel-across-drivers","title":"Keep method names predictable and parallel across drivers:","text":"<pre><code>adc.voltage()\npwm.freq()\npin.state()\ni2c.read()\n</code></pre> <p>Each method directly corresponds to the hardware behavior.</p>"},{"location":"concepts/naming/#documentation-standards","title":"\ud83d\udcd8 Documentation Standards","text":"<ul> <li>Docstrings: Use one-line summaries and optional extended sections.</li> <li>Type Hints: Required for all function signatures.</li> <li>Units: Always specify units in docstrings (e.g., <code>voltage() -&gt; float  # in volts</code>).</li> </ul> <p>Example:</p> <pre><code>def voltage(self) -&gt; float:\n    \"\"\"Return measured voltage (in volts).\"\"\"\n    return (self.raw() / self._max) * self.vref\n</code></pre>"},{"location":"concepts/naming/#api-behavior-rules","title":"\ud83e\udde0 API Behavior Rules","text":"<ul> <li>Avoid hidden state changes.</li> <li>Functions must be deterministic where possible.</li> <li>Always fail gracefully \u2014 raise or return an error object, never crash the system.</li> </ul>"},{"location":"concepts/naming/#example-unified-style","title":"\ud83e\udde9 Example Unified Style","text":"<pre><code># PicoCore Driver Example\nfrom core.drivers.adc import ADC\nfrom core.services.logger import Logger\n\nadc = ADC(26, r1=10000, r2=10000)\nlog = Logger()\n\nvalue = adc.real()\nlog.info(f\"Battery Voltage: {value:.2f}V\")\n</code></pre>"},{"location":"concepts/naming/#future-proofing-guidelines","title":"\ud83c\udfd7\ufe0f Future-Proofing Guidelines","text":"<ol> <li>Always add new methods in a backward-compatible way.</li> <li>Maintain symmetry: if there\u2019s a <code>read()</code>, there should be a <code>write()</code> when appropriate.</li> <li>Ensure naming remains meaningful when used across hardware layers.</li> </ol> <p>Example:</p> <pre><code># Good\nsensor.read()\n\n# Bad\nsensor.getData()\n</code></pre>"},{"location":"concepts/naming/#summary","title":"\ud83e\udded Summary","text":"Concept Rule File names lowercase Class names PascalCase Method names lowercase, one-word verbs Constants UPPERCASE Docstrings Short and clear Determinism Always preferred Failures Graceful, never crash <p>PicoCore Standard \u2014 Designed for elegance, predictability, and minimalism.</p>"},{"location":"concepts/versioning/","title":"Versioning","text":"<p>This page deals with the version structure of PicoCore.</p> <p>PicoCore uses a simple versioning system based on a <code>.version</code> file located in the <code>core</code> folder of the project. This file contains two lines:</p> <ol> <li>PicoCore version \u2013 the version of the PicoCore framework.</li> <li>MicroPython version \u2013 the version of MicroPython used.</li> </ol> <p>Example of a <code>.version</code> file:</p> .version<pre><code>2.0.0\n1.26.1\n</code></pre> <p>This <code>.version</code> file is important during compilation and documentation generation, as various processes rely on it.</p> <p>This page is mainly relevant for developers who want to build their own version of PicoCore or contribute to the project.</p>"},{"location":"conf/v1Legacy/config/","title":"Legacy V1","text":"<p>This file deals with the structure of the configuration file written in TOML format for the OS.</p>"},{"location":"conf/v1Legacy/config/#example","title":"Example","text":"<pre><code># PiScout Rover Configuration File\n\n[system]\nname = \"PiScout Rover\"\nversion = \"1.0\"\nenable_logging = true\ndebug_mode = false\n\n[system.logger]\nlevel = \"INFO\"\nbuffersize = 8\nmax = 50\ndebug = false\n\n[network]\n\n[network.bluetooth]\nenabled = true\nssid = \"Test\"\nkey = false\npassword = \"\"\n\n\n[network.wlan]\nenabled = false\npassword = \"test\"\nssid = \"test\"\n\n[motors]\n# Motor A - Left Wheel\n[motors.left]\npwm_pin = 15\ndir_pin = 14\nspeed_limit = 100  # Max 100%\n\n# Motor B - Right Wheel\n[motors.right]\npwm_pin = 17\ndir_pin = 16\nspeed_limit = 100  # Max 100%\n\n[sensors]\n# Ultrasonic Distance Sensor\n[sensors.ultrasonic]\ntrigger_pin = 10\necho_pin = 11\nmax_distance = 200  # cm\n\n# IMU (Accelerometer + Gyro)\n[sensors.imu]\ni2c_sda = 4\ni2c_scl = 5\nsampling_rate = 50  # Hz\n\n[power]\nbattery_voltage = 7.4  # Volts\nlow_battery_warning = 6.5  # Volts\n\n[logging]\nlog_to_console = true\nlog_to_file = true\nlog_level = \"INFO\"  # Options: \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"\nlog_file = \"/logs/piscout.log\"\n</code></pre>"},{"location":"conf/v2/config/","title":"PicoCore Configuration Guide","text":"<p>PicoCore uses a single <code>config.toml</code> file to configure system behavior, hardware features, logging, power management, and runtime options. This guide provides an overview of all available configuration fields and how to use them.</p>"},{"location":"conf/v2/config/#overview","title":"Overview","text":"<p>Place a <code>config.toml</code> file in the root of your PicoCore project. During startup, PicoCore automatically loads and parses the file to configure runtime behavior.</p> <p>This allows you to:</p> <ul> <li>Enable and configure the logger</li> <li>Adjust runtime loop speed</li> <li>Manage power monitoring and battery behavior</li> <li>Configure health checks and device indicators</li> </ul>"},{"location":"conf/v2/config/#full-example-configuration","title":"Full Example Configuration","text":"<p>Below is a full example demonstrating all available configuration fields:</p> <pre><code>[system]\n\n[system.logger]\nlevel = \"INFO\"\nbuffersize = 5\n# int (bytes) or string with suffix (\"1b\", \"1kb\", \"1mb\")\nmax_file_size = \"64kb\"\nlog_to_console = true\nlog_to_file = true\nmax_rotations = 3\n\n[system.health]\nonboard_status_led = false\ncheck_interval = 5000\n\n[system.runtime]\ninterval = 0.1 # in seconds\n\n[power]\n\n[power.monitoring]\nenabled = true\n\n[power.battery]\nbattery_voltage_max = 5.5        # Volts\nbattery_voltage_nominal = 5      # Volts\nbattery_voltage_cut_off = 3.3    # Volts\nbattery_ah = 2.4                 # Ampere-hours\nadc_pin = 28                     # ADC pin for voltage measurement\nmin_runtime = 10                 # minimum runtime in minutes\n\n[power.voltage_divider]\nenabled = true\nr1 = 10_000  # Resistance of R1 in Ohms\nr2 = 5_100  # Resistance of R2 in Ohms\n</code></pre>"},{"location":"conf/v2/config/#configuration-sections","title":"Configuration Sections","text":""},{"location":"conf/v2/config/#system","title":"<code>[system]</code>","text":"<p>Top-level system configuration.</p>"},{"location":"conf/v2/config/#systemlogger","title":"<code>[system.logger]</code>","text":"<p>Controls how PicoCore logs data.</p> <ul> <li> <p>level</p> <p>One of <code>OFF</code>, <code>FATAL</code>, <code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, <code>TRACE</code></p> <pre><code>    level = \"INFO\"\n</code></pre> </li> <li> <p>buffersize</p> <p>Buffer size for log entries in RAM.</p> <pre><code>    buffersize = 5\n</code></pre> <p>With this meaning <code>buffersize * 45 bytes</code>, where 45 bytes is the estimated size of a small log entry.</p> </li> </ul> <p>RAM vs. Flash</p> <p>The <code>buffersize</code> is for RAM, the <code>max_file_size</code> is for Flash.</p> <p>If RAM is full, logs are flushed to disk. If Flash is full, the oldest log file is deleted. When  <code>FATAL</code> , <code>ERROR</code> , or <code>WARN</code> logs are logged, the log buffer is flushed to disk immediately.</p> <ul> <li> <p>max_file_size</p> <p>Maximum log file size before rotation. Can either be:</p> <ul> <li>an integer (<code>bytes</code>) </li> </ul> <pre><code>max_file_size = 64_000\n</code></pre> <ul> <li>or a string with suffix (<code>1b</code>, <code>1kb</code>, <code>1mb</code>).</li> </ul> <pre><code>max_file_size = \"64kb\"\n</code></pre> </li> <li> <p>log_to_console</p> <p>Whether to output logs to REPL/serial.</p> <pre><code>    log_to_console = true\n</code></pre> </li> <li> <p>log_to_file</p> <p>Whether to save logs to filesystem.</p> <pre><code>    log_to_file = true\n</code></pre> </li> <li> <p>max_rotations</p> <p>Number of rotated log files to keep.</p> <pre><code>    max_rotations = 3\n</code></pre> <p>Meaning that 3 rotated log files will be kept before the oldest is deleted.</p> </li> </ul>"},{"location":"conf/v2/config/#systemruntime","title":"<code>[system.runtime]</code>","text":"<p>Configures the main runtime loop.</p> <ul> <li>interval: Loop delay in seconds</li> </ul>"},{"location":"conf/v2/config/#power","title":"<code>[power]</code>","text":"<p>Power management configuration.</p>"},{"location":"conf/v2/config/#powermonitoring","title":"<code>[power.monitoring]</code>","text":"<ul> <li>enabled: Turns power monitoring on/off</li> </ul> <p>Power Monitoring</p> <p>If enabled, PicoCore will use dynamic sleep to save power.Meaning it will go into a light sleep when idle.</p> <p>Planned: Support for deep sleep with state saving.</p>"},{"location":"conf/v2/config/#tips","title":"Tips","text":"<ul> <li>Values like <code>\"64kb\"</code> or <code>\"1mb\"</code> can simplify storage configuration.</li> <li>For all configurable fields, there is a default value if not specified or on Failure.</li> </ul>"},{"location":"conf/v2/config/#conclusion","title":"Conclusion","text":"<p>The <code>config.toml</code> file provides a flexible way to tailor PicoCore's behavior without modifying code. Adjust it according to your device setup, application logic, and power requirements.</p>"}]}